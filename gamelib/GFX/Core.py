import gamelib.HacExceptions
from math import sqrt
from gamelib import Constants
from gamelib.Assets import Graphics


class Sprixel(object):
    # A sprixel is the representation of 1 cell of the sprite. It is not really a pixel
    # but it is the closest notion we'll have.
    # A Sprixel has a background color, a foreground color and a model.
    # Therefor, all regular BoardItems can have use Sprixel.
    def __init__(self, model="", bg_color="", fg_color=""):
        super().__init__()
        self.model = model
        self.bg_color = bg_color
        self.fg_color = fg_color
        self.is_bg_transparent = False
        if bg_color is None or bg_color == "":
            self.is_bg_transparent = True

    def __repr__(self):
        return f"{self.bg_color}{self.fg_color}{self.model}\x1b[0m"

    def __str__(self):
        return self.__repr__()

    def __eq__(self, other):
        if (
            self.model == other.model
            and self.bg_color == other.bg_color
            and self.fg_color == other.fg_color
        ):
            return True
        else:
            return False

    def __ne__(self, other):
        if (
            self.model != other.model
            or self.bg_color != other.bg_color
            or self.fg_color != other.fg_color
        ):
            return True
        else:
            return False

    @staticmethod
    def from_ansi(string):
        """Takes an ANSI string, parse it and return a Sprixel.

        :param string: The ANSI string to parse.
        :type string: str

        Example::

            new_sprixel = Sprixel.from_ansi(
                "\\x1b[48;2;139;22;19m\\x1b[38;2;160;26;23m▄\\x1b[0m"
            )

        .. warning:: This has mainly be tested with ANSI string generated by climage.
        """
        new_sprixel = Sprixel()
        if "[48;" in string and "[38;" in string and "▄" in string:
            (colors, end) = string.split("▄")
            new_sprixel.model = "▄"
            for e in colors.split("m"):
                if "[48;" in e:
                    new_sprixel.bg_color = f"{e}m"
                elif "[38;" in e:
                    new_sprixel.fg_color = f"{e}m"
        elif "[38;" in string and "▄" in string:
            (colors, end) = string.split("▄")
            new_sprixel.model = "▄"
            for e in colors.split("m"):
                if "[38;" in e:
                    new_sprixel.fg_color = f"{e}m"
        elif "[48;" in string and "▄" in string:
            (colors, end) = string.split("▄")
            new_sprixel.model = "▄"
            for e in colors.split("m"):
                if "[48;" in e:
                    new_sprixel.bg_color = f"{e}m"
        return new_sprixel

    @property
    def model(self):
        return self.__model

    @model.setter
    def model(self, value):
        if type(value) is str:
            self.__model = value
        else:
            raise gamelib.HacExceptions.HacInvalidTypeException(
                f"A Sprixel.model must be a string. {value} is not a string."
            )

    @property
    def bg_color(self):
        return self.__bg_color

    @bg_color.setter
    def bg_color(self, value):
        if type(value) is str or "FormattingString" in str(type(value)):
            self.__bg_color = value
        else:
            raise gamelib.HacExceptions.HacInvalidTypeException(
                f"A Sprixel.bg_color must be a string. {value} is not a string."
            )

    @property
    def fg_color(self):
        return self.__fg_color

    @fg_color.setter
    def fg_color(self, value):
        if type(value) is str or "FormattingString" in str(type(value)):
            self.__fg_color = value
        else:
            raise gamelib.HacExceptions.HacInvalidTypeException(
                f"A Sprixel.fg_color must be a string. {value} is not a string."
            )

    def serialize(self):
        """Serialize a Sprixel into a dictionary.

        :returns: The class as a  dictionary
        :rtype: dict

        Example::

            json.dump( sprixel.serialize() )
        """
        return {
            "model": self.model,
            "bg_color": self.bg_color,
            "fg_color": self.fg_color,
        }

    @classmethod
    def black_rect(cls):
        return cls(" ", "\x1b[40m")

    @classmethod
    def black_square(cls):
        return cls("  ", "\x1b[40m")

    @classmethod
    def white_rect(cls):
        return cls(" ", "\x1b[47m")

    @classmethod
    def white_square(cls):
        return cls("  ", "\x1b[47m")

    @classmethod
    def red_rect(cls):
        return cls(" ", "\x1b[41m")

    @classmethod
    def red_square(cls):
        return cls("  ", "\x1b[41m")

    @classmethod
    def green_rect(cls):
        return cls(" ", "\x1b[42m")

    @classmethod
    def green_square(cls):
        return cls("  ", "\x1b[42m")

    @classmethod
    def blue_rect(cls):
        return cls(" ", "\x1b[44m")

    @classmethod
    def blue_square(cls):
        return cls("  ", "\x1b[44m")

    @classmethod
    def cyan_rect(cls):
        return cls(" ", "\x1b[46m")

    @classmethod
    def cyan_square(cls):
        return cls("  ", "\x1b[46m")

    @classmethod
    def magenta_rect(cls):
        return cls(" ", "\x1b[45m")

    @classmethod
    def magenta_square(cls):
        return cls("  ", "\x1b[45m")

    @classmethod
    def yellow_rect(cls):
        return cls(" ", "\x1b[43m")

    @classmethod
    def yellow_square(cls):
        return cls("  ", "\x1b[43m")


class Sprite(object):
    def __init__(
        self, size=[2, 2], sprixels=None, default_sprixel=Sprixel(), parent=None
    ):
        super().__init__()
        self.size = size
        self.parent = parent
        self.default_sprixel = default_sprixel
        # They are not pixels but they are atoms of the Sprite molecule...
        if sprixels is not None and len(sprixels) > 0:
            self._sprixels = []
            for row in range(0, size[1]):
                self._sprixels.append([])
                for column in range(0, size[0]):
                    self._sprixels[row].append(sprixels[row][column])

        else:
            self.empty()

    def __repr__(self):
        string = []
        for scanline in self._sprixels:
            string.append("".join(map(lambda i: i.__repr__(), scanline)))
        return "\n".join(string)

    def __str__(self):
        return self.__repr__()

    def empty(self):
        self._sprixels = [
            [self.default_sprixel for i in range(0, self.size[0])]
            for j in range(0, self.size[1])
        ]

    def sprixel(self, row=0, column=None):
        # WARNING: For performance consideration sprixel() does not check the size of
        # its matrix. This method is called many times during rendering and 2 calls to
        # len() in a row are adding up pretty quickly.
        if column is None:
            return self._sprixels[row]
        else:
            return self._sprixels[row][column]

    def set_sprixel(self, row, column, val):
        self._sprixels[row][column] = val

    @classmethod
    def load_from_ansi_file(cls, filename, default_sprixel=None):
        if default_sprixel is None:
            default_sprixel = Sprixel(" ", "", "")
        new_sprite = cls(default_sprixel=default_sprixel)
        with open(filename, "r") as sprite_file:
            sprixels_list = []
            height = 0
            max_width = 0
            while True:
                line = sprite_file.readline()
                if not line:
                    break
                width = 0
                sprixels_list.append([])
                for s in line.rstrip().split("▄"):
                    if s != "\x1b[0m":
                        sprixels_list[height].append(Sprixel.from_ansi(f"{s}▄\x1b[0m"))
                        width += 1
                if width > max_width:
                    max_width = width
                height += 1
            for row in range(0, len(sprixels_list)):
                if len(sprixels_list[row]) < max_width:
                    for column in range(len(sprixels_list[row]), max_width):
                        sprixels_list[row].append(default_sprixel)
            new_sprite._sprixels = sprixels_list
            new_sprite.size = [max_width, height]
        return new_sprite

    def flip_horizontally(self):
        new_sprite = Sprite(
            size=self.size,
            sprixels=None,
            default_sprixel=self.default_sprixel,
            parent=self.parent,
        )
        nc = 0
        # Flipping horizontally is just a symmetry vs a vertical axis
        for col in range(self.size[0] - 1, -1, -1):
            for row in range(0, self.size[1]):
                new_sprite.set_sprixel(row, nc, self._sprixels[row][col])
            nc += 1
        return new_sprite

    def flip_vertically(self):
        # If the sprite was created from an image using climage using ▄ as a delimiter
        # this function is going to flip the delimiter too and replace ▄ by ▀.
        new_sprite = Sprite(
            size=self.size,
            sprixels=None,
            default_sprixel=self.default_sprixel,
            parent=self.parent,
        )
        nr = 0
        for row in range(self.size[1] - 1, -1, -1):
            for col in range(0, self.size[0]):
                new_sprix = self._sprixels[row][col]
                if new_sprix.model == Graphics.Blocks.LOWER_HALF_BLOCK:
                    new_sprix.model = Graphics.Blocks.UPPER_HALF_BLOCK
                new_sprite.set_sprixel(nr, col, new_sprix)
            nr += 1
        return new_sprite

    def dimension(self):
        # Warning: dimension recalculate the size of the Sprite, it is much faster
        # although not safe to use self.size
        height = 0
        max_width = 0
        for row in self._sprixels:
            width = 0
            for col in row:
                width += 1
            if width > max_width:
                max_width = width
            height += 1
        self.size = [max_width, height]
        return self.size


class Vector2D:
    """A 2D vector class.

    Contrary to the rest of the library Vector2D uses floating point numbers for its
    coordinates/direction/orientation. However since the rest of the library uses
    integers, the numbers are rounded to 2 decimals.
    You can alter that behavior by increasing or decreasing (if you want integer for
    example)_

    Vector2D use the row/column internal naming convention as it is easier to visualize
    For learning developers. If it is a concept that you already understand and are
    more familiar with the x/y coordinate system you can also use x and y.

     - x is equivalent to column
     - y is equivalent to row

    Everything else is the same.

    :param name: some param
    :type name: str

    Example::

        method()
    """

    def __init__(self, row=0.0, column=0.0):
        # column is x and row is y
        self.__row = row
        self.__column = column
        self.rounding_precision = 2

    def __repr__(self):
        return f"{self.__class__.__name__} ({self.__row}, {self.__column})"

    def __str__(self):
        return self.__repr__()

    def __add__(self, other):
        row = round(self.__row + other.row, self.rounding_precision)
        column = round(self.__column + other.column, self.rounding_precision)
        return Vector2D(row, column)

    def __sub__(self, other):
        row = round(self.__row - other.row, self.rounding_precision)
        column = round(self.__column - other.column, self.rounding_precision)
        return Vector2D(row, column)

    def __mul__(self, other):
        if isinstance(other, (int, float)):
            return Vector2D(
                round(self.__row * other, self.rounding_precision),
                round(self.__column * other, self.rounding_precision),
            )
        if isinstance(other, Vector2D):
            return round(
                self.row * other.column - self.column * self.row,
                self.rounding_precision,
            )

    @property
    def row(self):
        return self.__row

    @row.setter
    def row(self, value):
        if isinstance(value, (int, float)):
            self.__row = round(value, self.rounding_precision)
        else:
            raise gamelib.HacExceptions.HacInvalidTypeException(
                "Vector2D.row needs to be an int or a float."
            )

    @property
    def y(self):
        return self.row

    @y.setter
    def y(self, value):
        self.row = value

    @property
    def column(self):
        return self.__column

    @column.setter
    def column(self, value):
        if isinstance(value, (int, float)):
            self.__column = round(value, self.rounding_precision)
        else:
            raise gamelib.HacExceptions.HacInvalidTypeException(
                "Vector2D.column needs to be an int or a float."
            )

    @property
    def x(self):
        return self.column

    @x.setter
    def x(self, value):
        self.column = value

    def length(self):
        return round(sqrt(self.row ** 2 + self.column ** 2), self.rounding_precision)

    def unit(self):
        """Returns a normalized unit vector.

        :returns: A unit vector
        :rtype: :class:`~gamelib.GFX.Core.Vector2D`

        Example::

            gravity = Vector2D(9.81, 0)
            next_position = item.position_as_vector() + gravity.unit()
        """
        return Vector2D(
            round(self.__row / self.length(), self.rounding_precision),
            round(self.__column / self.length(), self.rounding_precision),
        )

    @classmethod
    def from_direction(cls, direction, step):
        """Build and return a Vector2D from a direction.

        Directions are from the Constants module.

        :param direction: A direction from the Constants module.
        :type direction: int
        :param step: The number of cell to cross in one movement.
        :type step: int

        Example::

            v2d_up = Vector2D.from_direction(Constants.UP, 1)
        """
        if direction == Constants.NO_DIR:
            return cls(0, 0)
        elif direction == Constants.UP:
            return cls(-step, 0)
        elif direction == Constants.DOWN:
            return cls(+step, 0)
        elif direction == Constants.LEFT:
            return cls(0, -step)
        elif direction == Constants.RIGHT:
            return cls(0, +step)
        elif direction == Constants.DRUP:
            return cls(-step, +step)
        elif direction == Constants.DRDOWN:
            return cls(+step, +step)
        elif direction == Constants.DLUP:
            return cls(-step, -step)
        elif direction == Constants.DLDOWN:
            return cls(+step, -step)


class Screen(object):
    pass
