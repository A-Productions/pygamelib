"""This module contains the core classes for the "graphic" system.

.. autosummary::
   :toctree: .

   Sprixel
   Sprite
   Animation
   Screen
"""
import pygamelib.board_items as board_items
import pygamelib.base as base
import pygamelib.constants as constants
import pygamelib.assets.graphics as graphics
import time
import sys


class Sprixel(object):
    # A sprixel is the representation of 1 cell of the sprite. It is not really a pixel
    # but it is the closest notion we'll have.
    # A Sprixel has a background color, a foreground color and a model.
    # Therefor, all regular BoardItems can have use Sprixel.
    def __init__(self, model="", bg_color="", fg_color=""):
        super().__init__()
        self.model = model
        self.bg_color = bg_color
        self.fg_color = fg_color
        self.is_bg_transparent = False
        if bg_color is None or bg_color == "":
            self.is_bg_transparent = True

    def __repr__(self):
        return f"{self.bg_color}{self.fg_color}{self.model}\x1b[0m"

    def __str__(self):
        return self.__repr__()

    def __eq__(self, other):
        if (
            self.model == other.model
            and self.bg_color == other.bg_color
            and self.fg_color == other.fg_color
        ):
            return True
        else:
            return False

    def __ne__(self, other):
        if (
            self.model != other.model
            or self.bg_color != other.bg_color
            or self.fg_color != other.fg_color
        ):
            return True
        else:
            return False

    @staticmethod
    def from_ansi(string):
        """Takes an ANSI string, parse it and return a Sprixel.

        :param string: The ANSI string to parse.
        :type string: str

        Example::

            new_sprixel = Sprixel.from_ansi(
                "\\x1b[48;2;139;22;19m\\x1b[38;2;160;26;23m▄\\x1b[0m"
            )

        .. warning:: This has mainly be tested with ANSI string generated by climage.
        """
        new_sprixel = Sprixel()
        if "[48;" in string and "[38;" in string and "▄" in string:
            (colors, end) = string.split("▄")
            new_sprixel.model = "▄"
            for e in colors.split("m"):
                if "[48;" in e:
                    new_sprixel.bg_color = f"{e}m"
                elif "[38;" in e:
                    new_sprixel.fg_color = f"{e}m"
        elif "[38;" in string and "▄" in string:
            (colors, end) = string.split("▄")
            new_sprixel.model = "▄"
            for e in colors.split("m"):
                if "[38;" in e:
                    new_sprixel.fg_color = f"{e}m"
        elif "[48;" in string and "▄" in string:
            (colors, end) = string.split("▄")
            new_sprixel.model = "▄"
            for e in colors.split("m"):
                if "[48;" in e:
                    new_sprixel.bg_color = f"{e}m"
        return new_sprixel

    @property
    def model(self):
        return self.__model

    @model.setter
    def model(self, value):
        if type(value) is str:
            self.__model = value
        else:
            raise base.HacInvalidTypeException(
                f"A Sprixel.model must be a string. {value} is not a string."
            )

    @property
    def bg_color(self):
        return self.__bg_color

    @bg_color.setter
    def bg_color(self, value):
        if type(value) is str or "FormattingString" in str(type(value)):
            self.__bg_color = value
        else:
            raise base.HacInvalidTypeException(
                f"A Sprixel.bg_color must be a string. {value} is not a string."
            )

    @property
    def fg_color(self):
        return self.__fg_color

    @fg_color.setter
    def fg_color(self, value):
        if type(value) is str or "FormattingString" in str(type(value)):
            self.__fg_color = value
        else:
            raise base.HacInvalidTypeException(
                f"A Sprixel.fg_color must be a string. {value} is not a string."
            )

    def serialize(self):
        """Serialize a Sprixel into a dictionary.

        :returns: The class as a  dictionary
        :rtype: dict

        Example::

            json.dump( sprixel.serialize() )
        """
        return {
            "model": self.model,
            "bg_color": self.bg_color,
            "fg_color": self.fg_color,
        }

    @classmethod
    def black_rect(cls):
        return cls(" ", "\x1b[40m")

    @classmethod
    def black_square(cls):
        return cls("  ", "\x1b[40m")

    @classmethod
    def white_rect(cls):
        return cls(" ", "\x1b[47m")

    @classmethod
    def white_square(cls):
        return cls("  ", "\x1b[47m")

    @classmethod
    def red_rect(cls):
        return cls(" ", "\x1b[41m")

    @classmethod
    def red_square(cls):
        return cls("  ", "\x1b[41m")

    @classmethod
    def green_rect(cls):
        return cls(" ", "\x1b[42m")

    @classmethod
    def green_square(cls):
        return cls("  ", "\x1b[42m")

    @classmethod
    def blue_rect(cls):
        return cls(" ", "\x1b[44m")

    @classmethod
    def blue_square(cls):
        return cls("  ", "\x1b[44m")

    @classmethod
    def cyan_rect(cls):
        return cls(" ", "\x1b[46m")

    @classmethod
    def cyan_square(cls):
        return cls("  ", "\x1b[46m")

    @classmethod
    def magenta_rect(cls):
        return cls(" ", "\x1b[45m")

    @classmethod
    def magenta_square(cls):
        return cls("  ", "\x1b[45m")

    @classmethod
    def yellow_rect(cls):
        return cls(" ", "\x1b[43m")

    @classmethod
    def yellow_square(cls):
        return cls("  ", "\x1b[43m")


class Sprite(object):
    def __init__(
        self, sprixels=None, default_sprixel=Sprixel(), parent=None, size=[2, 2]
    ):
        super().__init__()
        self.size = size
        self.parent = parent
        self.default_sprixel = default_sprixel
        if sprixels is not None and len(sprixels) > 0:
            self._sprixels = []
            height = 0
            max_width = 0
            for row in sprixels:
                self._sprixels.append([])
                if len(row) > max_width:
                    max_width = len(row)
                width = 0
                for column in row:
                    self._sprixels[height].append(sprixels[height][width])
                    width += 1
                height += 1
            self.size = [len(self._sprixels), max_width]

        else:
            self.empty()

    def __repr__(self):
        string = []
        for scanline in self._sprixels:
            string.append("".join(map(lambda i: i.__repr__(), scanline)))
        return "\n".join(string)

    def __str__(self):
        return self.__repr__()

    def empty(self):
        self._sprixels = [
            [self.default_sprixel for i in range(0, self.size[0])]
            for j in range(0, self.size[1])
        ]

    def sprixel(self, row=0, column=None):
        # WARNING: For performance consideration sprixel() does not check the size of
        # its matrix. This method is called many times during rendering and 2 calls to
        # len() in a row are adding up pretty quickly.
        if column is None:
            return self._sprixels[row]
        else:
            return self._sprixels[row][column]

    def set_sprixel(self, row, column, val):
        self._sprixels[row][column] = val

    @classmethod
    def load_from_ansi_file(cls, filename, default_sprixel=None):
        if default_sprixel is None:
            default_sprixel = Sprixel(" ", "", "")
        new_sprite = cls(default_sprixel=default_sprixel)
        with open(filename, "r") as sprite_file:
            sprixels_list = []
            height = 0
            max_width = 0
            while True:
                line = sprite_file.readline()
                if not line:
                    break
                width = 0
                sprixels_list.append([])
                for s in line.rstrip().split("▄"):
                    if s != "\x1b[0m":
                        sprixels_list[height].append(Sprixel.from_ansi(f"{s}▄\x1b[0m"))
                        width += 1
                if width > max_width:
                    max_width = width
                height += 1
            for row in range(0, len(sprixels_list)):
                if len(sprixels_list[row]) < max_width:
                    for column in range(len(sprixels_list[row]), max_width):
                        sprixels_list[row].append(default_sprixel)
            new_sprite._sprixels = sprixels_list
            new_sprite.size = [max_width, height]
        return new_sprite

    def flip_horizontally(self):
        new_sprite = Sprite(
            size=self.size,
            sprixels=None,
            default_sprixel=self.default_sprixel,
            parent=self.parent,
        )
        nc = 0
        # Flipping horizontally is just a symmetry vs a vertical axis
        for col in range(self.size[0] - 1, -1, -1):
            for row in range(0, self.size[1]):
                new_sprite.set_sprixel(row, nc, self._sprixels[row][col])
            nc += 1
        return new_sprite

    def flip_vertically(self):
        # If the sprite was created from an image using climage using ▄ as a delimiter
        # this function is going to flip the delimiter too and replace ▄ by ▀.
        new_sprite = Sprite(
            size=self.size,
            sprixels=None,
            default_sprixel=self.default_sprixel,
            parent=self.parent,
        )
        nr = 0
        for row in range(self.size[1] - 1, -1, -1):
            for col in range(0, self.size[0]):
                new_sprix = self._sprixels[row][col]
                if new_sprix.model == graphics.Blocks.LOWER_HALF_BLOCK:
                    new_sprix.model = graphics.Blocks.UPPER_HALF_BLOCK
                new_sprite.set_sprixel(nr, col, new_sprix)
            nr += 1
        return new_sprite

    def calculate_size(self):
        # Warning: recalculate the size of the Sprite, it is much faster
        # although not safe to use self.size
        height = 0
        max_width = 0
        for row in self._sprixels:
            width = 0
            for col in row:
                width += 1
            if width > max_width:
                max_width = width
            height += 1
        self.size = [max_width, height]
        return self.size


class Animation(object):
    """
    The Animation class is used to give the ability to have more than one model
    for a BoardItem. A BoardItem can have an animation and all of them that
    are available to the Game object can be animated through
    Game.animate_items(lvl_number).
    To benefit from that, BoardItem.animation must be set explicitely.
    An animation is controlled via the same state system than the Actuators.

    The frames are all stored in a list called frames, that you can access
    through Animation.frames.

    :param display_time: The time each frame is displayed
    :type display_time: float
    :param auto_replay: controls the auto replay of the animation, if false
        once the animation is played it stays on the last
        frame of the animation.
    :type auto_replay: bool
    :param frames: an array of "frames" (string)
    :type frames: array[str]
    :param animated_object: The object to animate. This parameter is deprecated.
        Please use parent instead. It is only kept for backward compatibility.
        The parent parameter always takes precedence over this one.
    :type animated_object: :class:`~gamelib.BoardItem.BoardItem`
    :param parent: The parent object. It is also the object to animate.
        Important: We cannot animate anything else that BoardItems and subclasses.
    :type parent: :class:`~gamelib.BoardItem.BoardItem`
    :param refresh_screen: The callback function that controls the redrawing of
        the screen. This function reference should come from the main game.
    :type refresh_screen: function

    Example ::

        def redraw_screen(game_object):
            game_object.clear_screen()
            game_object.display_board()

        item = BoardItem(model=Sprite.ALIEN, name='Friendly Alien')
        # By default BoardItem does not have any animation, we have to
        # explicitely create one
        item.animation = Animation(display_time=0.1, parent=item,
                                   refresh_screen=redraw_screen)
    """

    def __init__(
        self,
        display_time=0.05,
        auto_replay=True,
        frames=None,
        animated_object=None,
        refresh_screen=None,
        initial_index=None,
        parent=None,
    ):
        self.state = constants.RUNNING
        self.display_time = display_time
        self.auto_replay = auto_replay
        if frames is None:
            frames = []
        self.frames = frames
        if initial_index is None:
            self._frame_index = 0
            self._initial_index = 0
        else:
            self._frame_index = initial_index
            self._initial_index = initial_index
        if animated_object is not None and parent is None:
            self.parent = animated_object
            self.animated_object = animated_object
        elif parent is not None:
            self.parent = parent
            self.animated_object = parent
        self.refresh_screen = refresh_screen

    def start(self):
        """Set the animation state to constants.RUNNING.

        If the animation state is not constants.RUNNING, animation's next_frame()
        function return the last frame returned.

        Example::

            item.animation.start()
        """
        self.state = constants.RUNNING

    def pause(self):
        """Set the animation state to PAUSED.

        Example::

            item.animation.pause()
        """
        self.state = constants.PAUSED

    def stop(self):
        """Set the animation state to STOPPED.

        Example::

            item.animation.stop()
        """
        self.state = constants.STOPPED

    def add_frame(self, frame):
        """Add a frame to the animation.

        The frame has to be a string (that includes sprites from the Sprite
        module and squares from the Utils module).

        Raise an exception if frame is not a string.

        :param frame: The frame to add to the animation.
        :type frame: str
        :raise: :class:`base.HacInvalidTypeException`

        Example::

            item.animation.add_frame(Sprite.ALIEN)
            item.animation.add_frame(Sprite.ALIEN_MONSTER)
        """
        if type(frame) is not str:
            raise base.HacInvalidTypeException(
                'The "frame" parameter must be a string.'
            )
        self.frames.append(frame)

    def search_frame(self, frame):
        """Search a frame in the animation.

        That method is returning the index of the first occurrence of "frame".

        Raise an exception if frame is not a string.

        :param frame: The frame to find.
        :type frame: str
        :rtype: int
        :raise: :class:`~pygamelib.base.HacInvalidTypeException`

        Example::

            item.animation.remove_frame(
                item.animation.search_frame(Sprite.ALIEN_MONSTER)
            )

        """
        if type(frame) is not str:
            raise base.HacInvalidTypeException(
                'The "frame" parameter must be a string.'
            )
        return self.frames.index(frame)

    def remove_frame(self, index):
        """Remove a frame from the animation.

        That method remove the frame at the specified index and return it
        if it exists.

        If the index is out of bound an exception is raised.
        If the index is not an int an exception is raised.

        :param index: The index of the frame to remove.
        :type index: int
        :rtype: str
        :raise: IndexError, HacInvalidTypeException

        Example::

            item.animation.remove_frame( item.animation.search_frame(
                Sprite.ALIEN_MONSTER)
            )

        """
        if type(index) is not int:
            raise base.HacInvalidTypeException('The "index" parameter must be an int.')
        if index <= self._frame_index and self._frame_index > 0:
            self._frame_index -= 1
        return self.frames.pop(index)

    def reset(self):
        """Reset the Animation to the first frame.

        Example::

            item.animation.reset()
        """
        self._frame_index = self._initial_index

    def current_frame(self):
        """Return the current frame.

        Example::

            item.model = item.animation.current_frame()
        """
        return self.frames[self._frame_index]

    def next_frame(self):
        """Update the parent.model with the next frame of the animation.

        That method takes care of automatically replaying the animation if the
        last frame is reached if the state is constants.RUNNING.

        If the the state is PAUSED it still update the parent.model
        and returning the current frame. It does NOT actually go to next frame.

        If parent is not a sub class of
        :class:`~gamelib.BoardItem.BoardItem` an exception is raised.

        :raise: :class:`~pygamelib.base.HacInvalidTypeException`

        Example::

            item.animation.next_frame()
        """
        if not isinstance(self.parent, board_items.BoardItem):
            raise base.HacInvalidTypeException(
                "The parent needs to be a sub class of BoardItem."
            )
        if self.state == constants.RUNNING:
            self._frame_index += 1
            if self._frame_index >= len(self.frames):
                if self.auto_replay:
                    self.reset()
                else:
                    self._frame_index = len(self.frames) - 1
            self.parent.model = self.frames[self._frame_index]
            return self.frames[self._frame_index]
        elif self.state == constants.PAUSED:
            self.parent.model = self.frames[self._frame_index]
            return self.frames[self._frame_index]
        # By default Python will return None for the STOPPED case.
        # This is debatable: why shouldn't we do the same thing
        # for STOPPED and PAUSED

    def play_all(self):
        """Play the entire animation once.

        That method plays the entire animation only once, there is no auto
        replay as it blocks the game (for the moment).

        If the the state is PAUSED or STOPPED, the animation does not play and
        the method return False.

        If parent is not a sub class of
        :class:`~gamelib.BoardItem.BoardItem` an exception is raised.

        If screen_refresh is not defined or is not a function an exception
        is raised.

        :raise: :class:`~pygamelib.base.HacInvalidTypeException`

        Example::

            item.animation.play_all()
        """
        if self.state == constants.PAUSED or self.state == constants.STOPPED:
            return False
        if self.refresh_screen is None or not callable(self.refresh_screen):
            raise base.HacInvalidTypeException(
                "The refresh_screen parameter needs to be a callback "
                "function reference."
            )
        if not isinstance(self.parent, board_items.BoardItem):
            raise base.HacInvalidTypeException(
                "The parent needs to be a sub class of BoardItem."
            )
        for f in self.frames:
            self.parent.model = f
            self.refresh_screen()
            time.sleep(self.display_time)
        return True


class Screen(object):
    def __init__(self, terminal=None):
        super().__init__()
        # get clear sequence for the terminal
        if terminal is None:
            raise base.PglException(
                "Screen must be constructed with a terminal object."
            )
        elif "blessed.terminal.Terminal" in str(type(terminal)):
            self.terminal = terminal
        else:
            raise base.PglException("Screen: terminal must be from the blessed module")

    def clear(self):
        """
        This methods clear the screen
        """
        sys.stdout.write(self.terminal.clear)
        sys.stdout.flush()
